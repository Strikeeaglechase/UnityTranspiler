import fs from "fs";
import path from "path";

import { appNamespace, geNamespace, outDir, unityProjPath, usings } from "./config.js";
import { createDir } from "./index.js";
import { getScriptTypes, TypeData } from "./prefab/scriptTypeExtractor.js";

const deletes: (string | RegExp)[] = [
	// "using UnityEngine;",
	// "using UnityEngine.UI;",
	// "using UnityEngine.UIElements;",
	// "using Unity.Profiling;",
	// "using UnityEngine.SocialPlatforms;",
	"using UnityEditor;",
	/using UnityEngine.+/g,
	/using Unity\..+/g,
	/using static Unity.+/g,
	"[HideInInspector]",
	"[CreateAssetMenu]",
	"[ExecuteAlways]",
	/\[Header\(.*\)]/g,
	/\[Tooltip\(.*\)]/g,
	/\[ContextMenu\(.*\)]/g,
	/\[Range\(.*\)]/g,
	/\[CreateAssetMenu\(.*\)]/g
];

const rewrites: { find: string | string[]; replace: string; if?: string | string[] | RegExp }[] = [
	// Logs
	{ find: "Debug.LogError", replace: "Logger.Error" },
	{ find: "Debug.LogWarning", replace: "Logger.Warn" },
	{ find: "Debug.LogException(e);", replace: "Logger.Error(e.Message);" },
	{ find: "Debug.Log", replace: "Logger.Info" },

	// Coroutines
	{ find: "new WaitForSeconds", replace: "new Wait" },
	{ find: "WaitForSeconds", replace: "Wait" },
	{ find: "new WaitForFixedUpdate()", replace: "new Wait(GameEngine.FixedUpdateEvent)" },
	{ find: "WaitForFixedUpdate", replace: "Wait" },
	{ find: "private IEnumerator ", replace: "private IEnumerator<Wait> " },
	{ find: "pubic IEnumerator ", replace: "public IEnumerator<Wait> " },
	{ find: "StartCoroutine(", replace: "CoroutineHandler.Start(" },
	{ find: "yield return null;", replace: "yield return new Wait(0);" },

	// Misc
	// { find: "Physics.gravity", replace: "(new Vector3(0, 9.8f, 0))" },
	{ find: "Application.dataPath", replace: `GameEngine.dataPath` },
	{ find: "Application.Quit();", replace: "GameEngine.instance.Quit();" },
	{ find: "Object.Destroy", replace: "GameObject.Destroy" },
	{ find: "UnityEngine.Object", replace: "GameObject" },
	{ find: "UnityEngine.Random", replace: `${geNamespace}.Random` }
];

// MonoBehaviour methods
const unityMonoMethodsRewrites = ["Awake", "Start", "Update", "FixedUpdate", "OnDestroy", "OnEnable", "OnDisable"];
unityMonoMethodsRewrites.forEach(method => {
	rewrites.push({
		find: [
			`public virtual void ${method}(`,
			`public override void ${method}(`,
			`public void ${method}(`,
			`private virtual void ${method}(`,
			`private override void ${method}(`,
			`private void ${method}(`,
			`void ${method}(`
		],
		replace: `protected override void ${method}(`
	});
});

interface ScriptData {
	name: string;
	guid: string;
	content: string;
	path: string;
	classTypes: TypeData;
	namespace: string;
}

function deleteBlocks(content: string) {
	const lines = content.split("\n");
	const result: string[] = [];

	for (let i = 0; i < lines.length; i++) {
		const line = lines[i];
		// console.log(line);

		if (line.includes("void OnDrawGizmos()") || line.includes("void OnDrawGizmosSelected()")) {
			let blockDepth = 1;
			i += 2; // Skip next line and the opening brace
			while (i < lines.length && blockDepth > 0) {
				const nextLine = lines[i];
				const openCount = (nextLine.match(/{/g) || []).length;
				const closeCount = (nextLine.match(/}/g) || []).length;

				blockDepth += openCount - closeCount;

				i++;
			}
			i--;

			continue;
		}

		// if (line.includes("// Unity Only Section Start")) {
		// 	while (i < lines.length && !lines[i].includes("// Unity Only Section End")) i++;

		// 	continue;
		// }

		result.push(line);
	}

	return result.join("\n");
}

function processScript(filePath: string): ScriptData {
	const fileLocalPath = filePath.substring((unityProjPath + "/Assets/Scripts").length + 1);
	const outPath = path.join(outDir, fileLocalPath);
	const metaFilePath = filePath + ".meta";
	if (!fs.existsSync(metaFilePath)) {
		console.warn(`Meta file not found for ${filePath}`);
		return null;
	}

	createDir(outPath);

	const metaFile = fs.readFileSync(filePath + ".meta", "utf8");
	const guid = metaFile.match(/guid: (.*)/)[1];

	let content = fs.readFileSync(filePath, "utf8");

	// Don't process auto-generated files
	if (content.includes("<auto-generated>")) return;
	if (content.toLowerCase().includes("// unity only file")) return;

	const types = getScriptTypes(filePath);

	const lines = content.split("\n");
	const firstBlankLineIdx = lines.findIndex(l => l.trim() == "");

	// Add namespace to files without it
	let namespace = null;
	if (!content.match(/namespace .+/)) {
		if (content.includes("using")) {
			const header = lines.slice(0, firstBlankLineIdx).join("\n");
			const newContent = lines
				.slice(firstBlankLineIdx)
				.map(l => `\t` + l)
				.join("\n");
			content = header + `\nnamespace ${appNamespace}\n{\n` + newContent + `\n}`;
		} else {
			const newContent = content
				.split("\n")
				.map(l => `\t` + l)
				.join("\n");
			content = `namespace ${appNamespace}\n{\n` + newContent + `\n}`;
		}
	} else {
		content = `using ${appNamespace};\n` + content;
		namespace = content.match(/namespace (.+)/)[1];
	}

	[...usings].reverse().forEach(u => (content = u + "\n" + content));

	rewrites.forEach(r => {
		if (r.if) {
			if (Array.isArray(r.if)) {
				if (!r.if.some(i => content.includes(i))) return;
			} else if (typeof r.if == "string") {
				if (!content.includes(r.if)) return;
			} else {
				if (!content.match(r.if)) return;
			}
		}

		if (Array.isArray(r.find)) {
			r.find.sort((a, b) => b.length - a.length);
			for (let i = 0; i < r.find.length; i++) {
				if (content.includes(r.find[i])) {
					content = content.replaceAll(r.find[i], r.replace);
					break;
				}
			}
		} else {
			content = content.replaceAll(r.find, r.replace);
		}
	});

	deletes.forEach(d => {
		content = content.replaceAll(d, "");
	});

	content = content
		.split("\n")
		.filter(l => !(l.includes("// Unity Only") && !l.includes("// Unity Only Section")))
		.join("\n");

	content = deleteBlocks(content);

	// Update logs to include [HSGE]
	content = content.replaceAll(/(Logger.\w+)\((.+)\)/g, '$1("[HSGE] " + $2)');

	fs.writeFileSync(outPath, content);

	return {
		name: path.basename(outPath, ".cs"),
		guid: guid,
		content: content,
		path: filePath,
		classTypes: types.find(t => t.name == path.basename(outPath, ".cs")),
		namespace: namespace
	};
}

export { processScript, ScriptData };
